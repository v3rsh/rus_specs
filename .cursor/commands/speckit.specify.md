---
description: Создать или обновить спецификацию функции из описания функции на естественном языке.
handoffs: 
  - label: Построить технический план
    agent: speckit.plan
    prompt: Создать план для спецификации. Я строю с...
  - label: Уточнить требования спецификации
    agent: speckit.clarify
    prompt: Уточнить требования спецификации
    send: true
---

## Ввод пользователя

```text
$ARGUMENTS
```

Вы **ДОЛЖНЫ** учитывать ввод пользователя перед продолжением (если он не пустой).

## План

Текст, который пользователь ввел после `/speckit.specify` в сообщении-триггере, **является** описанием функции. Предполагайте, что он всегда доступен в этом разговоре, даже если `$ARGUMENTS` появляется буквально ниже. Не просите пользователя повторить его, если только он не предоставил пустую команду.

Учитывая это описание функции, сделайте следующее:

1. **Сгенерируйте краткое короткое имя** (2-4 слова) для ветки:
   - Проанализируйте описание функции и извлеките наиболее значимые ключевые слова
   - Создайте короткое имя из 2-4 слов, которое отражает суть функции
   - Используйте формат действие-существительное, когда возможно (например, "добавить-аутентификацию", "исправить-баг-платежей")
   - Сохраняйте технические термины и аббревиатуры (OAuth2, API, JWT и т.д.)
   - Держите его кратким, но достаточно описательным, чтобы понять функцию с первого взгляда
     - Примеры:
     - "Хочу добавить аутентификацию пользователей" → "аутентификация-пользователей"
     - "Реализовать интеграцию OAuth2 для API" → "интеграция-oauth2-api"
     - "Создать дашборд для аналитики" → "дашборд-аналитики"
     - "Исправить баг таймаута обработки платежей" → "исправление-таймаута-платежей"

2. **Проверьте существующие ветки перед созданием новой**:

   a. Сначала получите все удаленные ветки, чтобы убедиться, что у нас есть последняя информация:

      ```bash
      git fetch --all --prune
      ```

   b. Найдите наибольший номер функции во всех источниках для короткого имени:
      - Удаленные ветки: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - Локальные ветки: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - Директории спецификаций: Проверьте директории, соответствующие `specs/[0-9]+-<short-name>`

   c. Определите следующий доступный номер:
      - Извлеките все номера из всех трех источников
      - Найдите наибольший номер N
      - Используйте N+1 для нового номера ветки

   d. Запустите скрипт `.specify/scripts/powershell/create-new-feature.ps1 -Json "$ARGUMENTS"` с рассчитанным номером и коротким именем:
      - Передайте `--number N+1` и `--short-name "ваше-короткое-имя"` вместе с описанием функции
      - Пример Bash: `.specify/scripts/powershell/create-new-feature.ps1 -Json "$ARGUMENTS" --json --number 5 --short-name "аутентификация-пользователей" "Добавить аутентификацию пользователей"`
      - Пример PowerShell: `.specify/scripts/powershell/create-new-feature.ps1 -Json "$ARGUMENTS" -Json -Number 5 -ShortName "аутентификация-пользователей" "Добавить аутентификацию пользователей"`

   **ВАЖНО**:
   - Проверьте все три источника (удаленные ветки, локальные ветки, директории спецификаций), чтобы найти наибольший номер
   - Сопоставляйте только ветки/директории с точным паттерном короткого имени
   - Если не найдено существующих веток/директорий с этим коротким именем, начните с номера 1
   - Вы должны запускать этот скрипт только один раз на функцию
   - JSON предоставляется в терминале как вывод — всегда ссылайтесь на него, чтобы получить фактическое содержимое, которое вы ищете
   - JSON вывод будет содержать пути BRANCH_NAME и SPEC_FILE
   - Для одинарных кавычек в аргументах типа "I'm Groot" используйте синтаксис экранирования: например, 'I'\''m Groot' (или двойные кавычки, если возможно: "I'm Groot")

3. Загрузите `.specify/templates/spec-template.md`, чтобы понять требуемые разделы.

4. Следуйте этому потоку выполнения:

   1. Распарсите описание пользователя из Ввода
      Если пусто: ОШИБКА "Описание функции не предоставлено"
   2. Извлеките ключевые концепции из описания
      Определите: акторы, действия, данные, ограничения
   3. Для неясных аспектов:
      - Делайте обоснованные предположения на основе контекста и отраслевых стандартов
      - Помечайте только [ТРЕБУЕТ УТОЧНЕНИЯ: конкретный вопрос], если:
        - Выбор существенно влияет на область функции или пользовательский опыт
        - Существуют множественные разумные интерпретации с разными последствиями
        - Не существует разумного значения по умолчанию
      - **ЛИМИТ: Максимум 3 маркера [ТРЕБУЕТ УТОЧНЕНИЯ] всего**
      - Приоритизируйте уточнения по влиянию: область > безопасность/конфиденциальность > пользовательский опыт > технические детали
   4. Заполните раздел Пользовательские сценарии и тестирование
      Если нет четкого пользовательского потока: ОШИБКА "Невозможно определить пользовательские сценарии"
   5. Сгенерируйте Функциональные требования
      Каждое требование должно быть проверяемым
      Используйте разумные значения по умолчанию для неуказанных деталей (документируйте предположения в разделе Предположения)
   6. Определите Критерии успеха
      Создайте измеримые, технологически-агностичные результаты
      Включите как количественные метрики (время, производительность, объем), так и качественные меры (удовлетворенность пользователей, завершение задач)
      Каждый критерий должен быть проверяемым без деталей реализации
   7. Определите Ключевые сущности (если задействованы данные)
   8. Верните: УСПЕХ (спецификация готова к планированию)

5. Запишите спецификацию в SPEC_FILE, используя структуру шаблона, заменяя плейсхолдеры конкретными деталями, выведенными из описания функции (аргументов), сохраняя порядок разделов и заголовки.

6. **Валидация качества спецификации**: После написания начальной спецификации валидируйте ее по критериям качества:

   a. **Создайте чеклист качества спецификации**: Сгенерируйте файл чеклиста в `FEATURE_DIR/checklists/requirements.md`, используя структуру шаблона чеклиста с этими элементами валидации:

      ```markdown
      # Чеклист качества спецификации: [ИМЯ ФУНКЦИИ]
      
      **Назначение**: Валидировать полноту и качество спецификации перед переходом к планированию
      **Создан**: [ДАТА]
      **Функция**: [Ссылка на spec.md]
      
      ## Качество содержимого
      
      - [ ] Нет деталей реализации (языки, фреймворки, API)
      - [ ] Сфокусировано на ценности для пользователя и бизнес-потребностях
      - [ ] Написано для нетехнических стейкхолдеров
      - [ ] Все обязательные разделы завершены
      
      ## Полнота требований
      
      - [ ] Не осталось маркеров [ТРЕБУЕТ УТОЧНЕНИЯ]
      - [ ] Требования проверяемы и однозначны
      - [ ] Критерии успеха измеримы
      - [ ] Критерии успеха технологически-агностичны (нет деталей реализации)
      - [ ] Все сценарии приемки определены
      - [ ] Граничные случаи идентифицированы
      - [ ] Область четко ограничена
      - [ ] Зависимости и предположения идентифицированы
      
      ## Готовность функции
      
      - [ ] Все функциональные требования имеют четкие критерии приемки
      - [ ] Пользовательские сценарии охватывают основные потоки
      - [ ] Функция соответствует измеримым результатам, определенным в Критериях успеха
      - [ ] Детали реализации не просачиваются в спецификацию
      
      ## Примечания
      
      - Элементы, помеченные как незавершенные, требуют обновления спецификации перед `/speckit.clarify` или `/speckit.plan`
      ```

   b. **Запустите проверку валидации**: Просмотрите спецификацию по каждому элементу чеклиста:
      - Для каждого элемента определите, проходит он или не проходит
      - Документируйте конкретные найденные проблемы (цитируйте соответствующие разделы спецификации)

   c. **Обработайте результаты валидации**:

      - **Если все элементы проходят**: Отметьте чеклист завершенным и переходите к шагу 6

      - **Если элементы не проходят (исключая [ТРЕБУЕТ УТОЧНЕНИЯ])**:
        1. Перечислите неудачные элементы и конкретные проблемы
        2. Обновите спецификацию для решения каждой проблемы
        3. Перезапустите валидацию, пока все элементы не пройдут (максимум 3 итерации)
        4. Если все еще не проходит после 3 итераций, документируйте оставшиеся проблемы в примечаниях чеклиста и предупредите пользователя

      - **Если остаются маркеры [ТРЕБУЕТ УТОЧНЕНИЯ]**:
        1. Извлеките все маркеры [ТРЕБУЕТ УТОЧНЕНИЯ: ...] из спецификации
        2. **ПРОВЕРКА ЛИМИТА**: Если существует более 3 маркеров, оставьте только 3 наиболее критических (по влиянию области/безопасности/UX) и сделайте обоснованные предположения для остальных
        3. Для каждого необходимого уточнения (максимум 3) представьте опции пользователю в этом формате:

           ```markdown
           ## Вопрос [N]: [Тема]
           
           **Контекст**: [Цитировать соответствующий раздел спецификации]
           
           **Что нам нужно знать**: [Конкретный вопрос из маркера ТРЕБУЕТ УТОЧНЕНИЯ]
           
           **Предложенные ответы**:
           
           | Опция | Ответ | Последствия |
           |-------|-------|-------------|
           | A     | [Первый предложенный ответ] | [Что это означает для функции] |
           | B     | [Второй предложенный ответ] | [Что это означает для функции] |
           | C     | [Третий предложенный ответ] | [Что это означает для функции] |
           | Свой  | Предоставьте свой ответ | [Объяснить, как предоставить свой ввод] |
           
           **Ваш выбор**: _[Ожидание ответа пользователя]_
           ```

        4. **КРИТИЧНО — Форматирование таблицы**: Убедитесь, что таблицы markdown правильно отформатированы:
           - Используйте согласованные пробелы с выровненными трубами
           - Каждая ячейка должна иметь пробелы вокруг содержимого: `| Content |`, а не `|Content|`
           - Разделитель заголовка должен иметь минимум 3 тире: `|--------|`
           - Проверьте, что таблица правильно отображается в предпросмотре markdown
        5. Нумеруйте вопросы последовательно (Q1, Q2, Q3 — максимум 3 всего)
        6. Представьте все вопросы вместе перед ожиданием ответов
        7. Дождитесь ответа пользователя с их выбором для всех вопросов (например, "Q1: A, Q2: Custom - [details], Q3: B")
        8. Обновите спецификацию, заменив каждый маркер [ТРЕБУЕТ УТОЧНЕНИЯ] выбранным или предоставленным ответом пользователя
        9. Перезапустите валидацию после разрешения всех уточнений

   d. **Обновите чеклист**: После каждой итерации валидации обновите файл чеклиста текущим статусом прохождения/непрохождения

7. Отчитайтесь о завершении с именем ветки, путем к файлу спецификации, результатами чеклиста и готовностью к следующей фазе (`/speckit.clarify` или `/speckit.plan`).

**ПРИМЕЧАНИЕ:** Скрипт создает и переключается на новую ветку и инициализирует файл спецификации перед записью.

## Общие руководящие принципы

## Краткие руководящие принципы

- Фокус на **ЧТО** нужно пользователям и **ПОЧЕМУ**.
- Избегайте КАК реализовать (без технологического стека, API, структуры кода).
- Написано для бизнес-стейкхолдеров, а не разработчиков.
- НЕ создавайте никаких чеклистов, встроенных в спецификацию. Это будет отдельная команда.

### Требования к разделам

- **Обязательные разделы**: Должны быть завершены для каждой функции
- **Опциональные разделы**: Включайте только когда релевантны функции
- Когда раздел не применим, удалите его полностью (не оставляйте как "N/A")

### Для генерации AI

При создании этой спецификации из промпта пользователя:

1. **Делайте обоснованные предположения**: Используйте контекст, отраслевые стандарты и общие паттерны для заполнения пробелов
2. **Документируйте предположения**: Записывайте разумные значения по умолчанию в разделе Предположения
3. **Ограничьте уточнения**: Максимум 3 маркера [ТРЕБУЕТ УТОЧНЕНИЯ] — используйте только для критических решений, которые:
   - Существенно влияют на область функции или пользовательский опыт
   - Имеют множественные разумные интерпретации с разными последствиями
   - Не имеют разумного значения по умолчанию
4. **Приоритизируйте уточнения**: область > безопасность/конфиденциальность > пользовательский опыт > технические детали
5. **Думайте как тестировщик**: Каждое расплывчатое требование должно не пройти элемент чеклиста "проверяемое и однозначное"
6. **Общие области, требующие уточнения** (только если не существует разумного значения по умолчанию):
   - Область функции и границы (включить/исключить конкретные случаи использования)
   - Типы пользователей и разрешения (если возможны множественные конфликтующие интерпретации)
   - Требования безопасности/соответствия (когда юридически/финансово значимы)

**Примеры разумных значений по умолчанию** (не спрашивайте об этих):

- Хранение данных: Отраслевые стандартные практики для домена
- Цели производительности: Стандартные ожидания веб/мобильных приложений, если не указано
- Обработка ошибок: Пользовательские сообщения с соответствующими запасными вариантами
- Метод аутентификации: Стандартный сеансовый или OAuth2 для веб-приложений
- Паттерны интеграции: RESTful API, если не указано иное

### Руководящие принципы критериев успеха

Критерии успеха должны быть:

1. **Измеримыми**: Включайте конкретные метрики (время, процент, количество, скорость)
2. **Технологически-агностичными**: Без упоминания фреймворков, языков, баз данных или инструментов
3. **Ориентированными на пользователя**: Описывайте результаты с точки зрения пользователя/бизнеса, а не внутренностей системы
4. **Проверяемыми**: Можно протестировать/валидировать без знания деталей реализации

**Хорошие примеры**:

- "Пользователи могут завершить оформление заказа менее чем за 3 минуты"
- "Система поддерживает 10,000 одновременных пользователей"
- "95% поисков возвращают результаты менее чем за 1 секунду"
- "Скорость завершения задач улучшается на 40%"

**Плохие примеры** (ориентированные на реализацию):

- "Время отклика API менее 200 мс" (слишком технично, используйте "Пользователи видят результаты мгновенно")
- "База данных может обрабатывать 1000 транзакций в секунду" (деталь реализации, используйте метрику, ориентированную на пользователя)
- "Компоненты React рендерятся эффективно" (специфично для фреймворка)
- "Процент попаданий кэша Redis выше 80%" (специфично для технологии)
